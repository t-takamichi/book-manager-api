name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: password
          MYSQL_DATABASE: test_db
        ports:
          - 33060:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -p$${MYSQL_ROOT_PASSWORD}"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    env:
      DATABASE_URL: mysql://root:password@127.0.0.1:33060/test_db
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Typecheck
        run: npx tsc --noEmit

      - name: Install MySQL client
        run: sudo apt-get update && sudo apt-get install -y default-mysql-client

      - name: Wait for MySQL to be ready
        run: |
          for i in {1..60}; do
            if mysqladmin ping -h 127.0.0.1 -P 33060 -uroot -ppassword >/dev/null 2>&1; then
              echo "MySQL is up"
              break
            fi
            echo "Waiting for MySQL... ($i)"
            sleep 2
          done


      # Unit tests are executed inside the containerized environment below to
      # ensure the same runtime and DB are used for E2E and integration tests.
      - name: Build and run containerized E2E (Docker Compose)
        run: |
          # Create .env for docker-compose (CI runner doesn't have one)
          cat > .env <<'EOF'
          MYSQL_ROOT_PASSWORD=verysecret
          MYSQL_DATABASE=app_db
          MYSQL_USER=app
          MYSQL_PASSWORD=verysecret
          DB_USER=app
          DB_PASS=verysecret
          DB_NAME=app_db
          DATABASE_URL=mysql://app:verysecret@db-primary:3306/app_db
          DATABASE_URL_WRITE=mysql://app:verysecret@db-primary:3306/app_db
          DATABASE_URL_READ=mysql://app:verysecret@db-primary:3306/app_db
          SEED_ON_STARTUP=true
          EOF

          # Build images (keep devDependencies in the image so tests can run inside the container)
          docker compose build --no-cache --pull --build-arg PRUNE_PRODUCTION=false

          # Start services
          docker compose up -d

          # Wait for db-primary to be ready
          echo "Waiting for db-primary to accept connections..."
          for i in {1..60}; do
            docker compose exec -T db-primary mysqladmin ping -h 127.0.0.1 -P 3306 -u app -pverysecret >/dev/null 2>&1 && { echo "db ready"; break; }
            echo -n "."
            sleep 2
          done

          # Run migrations, generate client and tests inside app
          docker compose exec -T app sh -c '
            DATABASE_URL="mysql://app:verysecret@db-primary:3306/app_db" npx prisma migrate deploy --schema=prisma/schema.prisma && 
              DATABASE_URL="mysql://app:verysecret@db-primary:3306/app_db" npx prisma generate --schema=prisma/schema.prisma && 
              CI=true NODE_ENV=test DATABASE_URL="mysql://app:verysecret@db-primary:3306/app_db" npx jest --runInBand --verbose
          '

      - name: Teardown containerized services
        if: always()
        run: docker compose down -v
